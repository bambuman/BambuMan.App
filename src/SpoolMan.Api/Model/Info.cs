// <auto-generated>
/*
 * Spoolman REST API v1
 *
 *      REST API for Spoolman.      The API is served on the path `/api/v1/`.      Some endpoints also serve a websocket on the same path. The websocket is used to listen for changes to the data     that the endpoint serves. The websocket messages are JSON objects. Additionally, there is a root-level websocket     endpoint that listens for changes to any data in the database.     
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using SpoolMan.Api.Client;

namespace SpoolMan.Api.Model
{
    /// <summary>
    /// Info
    /// </summary>
    public partial class Info : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Info" /> class.
        /// </summary>
        /// <param name="varVersion">varVersion</param>
        /// <param name="debugMode">debugMode</param>
        /// <param name="automaticBackups">automaticBackups</param>
        /// <param name="dataDir">dataDir</param>
        /// <param name="logsDir">logsDir</param>
        /// <param name="backupsDir">backupsDir</param>
        /// <param name="dbType">dbType</param>
        /// <param name="gitCommit">gitCommit</param>
        /// <param name="buildDate">buildDate</param>
        [JsonConstructor]
        public Info(string varVersion, bool debugMode, bool automaticBackups, string dataDir, string logsDir, string backupsDir, string dbType, Option<string?> gitCommit = default, Option<string?> buildDate = default)
        {
            VarVersion = varVersion;
            DebugMode = debugMode;
            AutomaticBackups = automaticBackups;
            DataDir = dataDir;
            LogsDir = logsDir;
            BackupsDir = backupsDir;
            DbType = dbType;
            GitCommitOption = gitCommit;
            BuildDateOption = buildDate;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Gets or Sets VarVersion
        /// </summary>
        [JsonPropertyName("version")]
        public string VarVersion { get; set; }

        /// <summary>
        /// Gets or Sets DebugMode
        /// </summary>
        [JsonPropertyName("debug_mode")]
        public bool DebugMode { get; set; }

        /// <summary>
        /// Gets or Sets AutomaticBackups
        /// </summary>
        [JsonPropertyName("automatic_backups")]
        public bool AutomaticBackups { get; set; }

        /// <summary>
        /// Gets or Sets DataDir
        /// </summary>
        [JsonPropertyName("data_dir")]
        public string DataDir { get; set; }

        /// <summary>
        /// Gets or Sets LogsDir
        /// </summary>
        [JsonPropertyName("logs_dir")]
        public string LogsDir { get; set; }

        /// <summary>
        /// Gets or Sets BackupsDir
        /// </summary>
        [JsonPropertyName("backups_dir")]
        public string BackupsDir { get; set; }

        /// <summary>
        /// Gets or Sets DbType
        /// </summary>
        [JsonPropertyName("db_type")]
        public string DbType { get; set; }

        /// <summary>
        /// Used to track the state of GitCommit
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> GitCommitOption { get; private set; }

        /// <summary>
        /// Gets or Sets GitCommit
        /// </summary>
        [JsonPropertyName("git_commit")]
        public string? GitCommit { get { return this.GitCommitOption; } set { this.GitCommitOption = new(value); } }

        /// <summary>
        /// Used to track the state of BuildDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> BuildDateOption { get; private set; }

        /// <summary>
        /// Gets or Sets BuildDate
        /// </summary>
        [JsonPropertyName("build_date")]
        public string? BuildDate { get { return this.BuildDateOption; } set { this.BuildDateOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Info {\n");
            sb.Append("  VarVersion: ").Append(VarVersion).Append("\n");
            sb.Append("  DebugMode: ").Append(DebugMode).Append("\n");
            sb.Append("  AutomaticBackups: ").Append(AutomaticBackups).Append("\n");
            sb.Append("  DataDir: ").Append(DataDir).Append("\n");
            sb.Append("  LogsDir: ").Append(LogsDir).Append("\n");
            sb.Append("  BackupsDir: ").Append(BackupsDir).Append("\n");
            sb.Append("  DbType: ").Append(DbType).Append("\n");
            sb.Append("  GitCommit: ").Append(GitCommit).Append("\n");
            sb.Append("  BuildDate: ").Append(BuildDate).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="Info" />
    /// </summary>
    public class InfoJsonConverter : JsonConverter<Info>
    {
        /// <summary>
        /// Deserializes json to <see cref="Info" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override Info Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> varVersion = default;
            Option<bool?> debugMode = default;
            Option<bool?> automaticBackups = default;
            Option<string?> dataDir = default;
            Option<string?> logsDir = default;
            Option<string?> backupsDir = default;
            Option<string?> dbType = default;
            Option<string?> gitCommit = default;
            Option<string?> buildDate = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "version":
                            varVersion = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "debug_mode":
                            debugMode = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "automatic_backups":
                            automaticBackups = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "data_dir":
                            dataDir = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "logs_dir":
                            logsDir = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "backups_dir":
                            backupsDir = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "db_type":
                            dbType = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "git_commit":
                            gitCommit = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "build_date":
                            buildDate = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!varVersion.IsSet)
                throw new ArgumentException("Property is required for class Info.", nameof(varVersion));

            if (!debugMode.IsSet)
                throw new ArgumentException("Property is required for class Info.", nameof(debugMode));

            if (!automaticBackups.IsSet)
                throw new ArgumentException("Property is required for class Info.", nameof(automaticBackups));

            if (!dataDir.IsSet)
                throw new ArgumentException("Property is required for class Info.", nameof(dataDir));

            if (!logsDir.IsSet)
                throw new ArgumentException("Property is required for class Info.", nameof(logsDir));

            if (!backupsDir.IsSet)
                throw new ArgumentException("Property is required for class Info.", nameof(backupsDir));

            if (!dbType.IsSet)
                throw new ArgumentException("Property is required for class Info.", nameof(dbType));

            if (varVersion.IsSet && varVersion.Value == null)
                throw new ArgumentNullException(nameof(varVersion), "Property is not nullable for class Info.");

            if (debugMode.IsSet && debugMode.Value == null)
                throw new ArgumentNullException(nameof(debugMode), "Property is not nullable for class Info.");

            if (automaticBackups.IsSet && automaticBackups.Value == null)
                throw new ArgumentNullException(nameof(automaticBackups), "Property is not nullable for class Info.");

            if (dataDir.IsSet && dataDir.Value == null)
                throw new ArgumentNullException(nameof(dataDir), "Property is not nullable for class Info.");

            if (logsDir.IsSet && logsDir.Value == null)
                throw new ArgumentNullException(nameof(logsDir), "Property is not nullable for class Info.");

            if (backupsDir.IsSet && backupsDir.Value == null)
                throw new ArgumentNullException(nameof(backupsDir), "Property is not nullable for class Info.");

            if (dbType.IsSet && dbType.Value == null)
                throw new ArgumentNullException(nameof(dbType), "Property is not nullable for class Info.");

            return new Info(varVersion.Value!, debugMode.Value!.Value!, automaticBackups.Value!.Value!, dataDir.Value!, logsDir.Value!, backupsDir.Value!, dbType.Value!, gitCommit, buildDate);
        }

        /// <summary>
        /// Serializes a <see cref="Info" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="info"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, Info info, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, info, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="Info" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="info"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, Info info, JsonSerializerOptions jsonSerializerOptions)
        {
            if (info.VarVersion == null)
                throw new ArgumentNullException(nameof(info.VarVersion), "Property is required for class Info.");

            if (info.DataDir == null)
                throw new ArgumentNullException(nameof(info.DataDir), "Property is required for class Info.");

            if (info.LogsDir == null)
                throw new ArgumentNullException(nameof(info.LogsDir), "Property is required for class Info.");

            if (info.BackupsDir == null)
                throw new ArgumentNullException(nameof(info.BackupsDir), "Property is required for class Info.");

            if (info.DbType == null)
                throw new ArgumentNullException(nameof(info.DbType), "Property is required for class Info.");

            writer.WriteString("version", info.VarVersion);

            writer.WriteBoolean("debug_mode", info.DebugMode);

            writer.WriteBoolean("automatic_backups", info.AutomaticBackups);

            writer.WriteString("data_dir", info.DataDir);

            writer.WriteString("logs_dir", info.LogsDir);

            writer.WriteString("backups_dir", info.BackupsDir);

            writer.WriteString("db_type", info.DbType);

            if (info.GitCommitOption.IsSet)
                if (info.GitCommitOption.Value != null)
                    writer.WriteString("git_commit", info.GitCommit);
                else
                    writer.WriteNull("git_commit");

            if (info.BuildDateOption.IsSet)
                if (info.BuildDateOption.Value != null)
                    writer.WriteString("build_date", info.BuildDate);
                else
                    writer.WriteNull("build_date");
        }
    }
}
